---
alwaysApply: false
---

# Code Guidelines: Development Workflow Standards

## Overview

This document defines a streamlined workflow for managing code, documentation, and tests that follows the natural development process: Code → Documentation → Tests.

## Core Development Workflow

### Step 1: Code Development

- **Write code first** - Focus on implementation without documentation overhead
- **Use TSDoc for API documentation** - Document all @public elements clearly
- **Clear API documentation** - Document what each function/class does

**TSDoc Requirements**:

- **Document all @public elements** - Functions, classes, interfaces, types
- **Mark internal elements** - Use `@internal` for non-exported elements
- **Clear descriptions** - Explain what it does, not how it works
- **Type parameters** - Use `@typeParam` for generics
- **Parameters and returns** - Use `@param` and `@returns`
- **Error documentation** - Use `@throws` with `@link` to error types
- **Tag positioning** - `@public`, `@internal` at end

**Public vs Internal Rules**:

- **@public Elements**: MUST be exported, MUST have clear TSDoc documentation
- **@internal Elements**: NO export, minimal documentation
- **Builder Pattern**: Interfaces and methods are @internal, factory functions are @public

### Step 2: Test Planning

- **Identify test scenarios** - Plan what needs to be tested for each @public element
- **Cover success and error paths** - Plan both happy path and error handling tests
- **Plan edge cases** - Identify boundary conditions and extreme scenarios
- **Focus on Public API** - Test what users will actually use
- **Keep tests focused** - One test per concept, avoid complex test logic

**Test Categories to Plan**:

1. **Basic Functionality** - Test the core behavior of each @public element
2. **Parameter Variations** - Test different input types and values
3. **Error Handling** - Test how errors are handled and returned
4. **Edge Cases** - Test boundary conditions and extreme scenarios
5. **Integration** - Test how multiple functions work together
6. **Return Values** - Test different output types and structures

### Step 3: Test Implementation

- **Write focused tests** - One test per concept, clear test names
- **Test Public API thoroughly** - Cover all @public functions, classes, and constructors
- **Use realistic scenarios** - Test with real-world input values
- **Validate outputs** - Test both success and error cases
- **Keep tests simple** - Avoid complex test logic, focus on behavior

### Step 4: Test Generation

- **Comprehensive Public API testing** - Test all @public functions, classes, and constructors
- **Edge cases and error handling** - Test boundary conditions and error scenarios
- **Type safety validation** - Test all @public elements with `expectTypeOf`
- **Complete coverage** - All aspects covered systematically

**Test Structure**:

```typescript
describe('ModuleName', () => {
  describe('Public API', () => {
    // Test core functionality of all @public elements
  };

  describe('Edge Cases & Error Handling', () => {
    // Boundary conditions and error handling
  });

  describe('Type Safety', () => {
    // TypeScript type validation
  });
});
```

**Test Categories & Responsibilities**:

1. **Public API**:
   - **Purpose**: Test core functionality of all @public elements
   - **Characteristics**: Test basic behavior, parameter variations, return values
   - **Focus**: Core functionality and normal usage

2. **Edge Cases & Error Handling**:
   - **Purpose**: Test boundary conditions and error scenarios
   - **Characteristics**: Test extreme cases, invalid inputs, error handling
   - **Focus**: Robustness and resilience

3. **Type Safety**:
   - **Purpose**: Validate TypeScript type safety
   - **Characteristics**: Test ALL @public elements with `expectTypeOf`
   - **Focus**: Type inference and constraints

## File Structure

```text
tests/
  component.spec.ts    # Tests for component module
  event.spec.ts        # Tests for event module
src/
  component.ts         # Source code with TSDoc
```

## Test Generation Rules

### 1. No Overlap Principle

- **Public API**: Test core functionality and normal usage
- **Edge Cases**: Test boundary conditions and error handling
- **Type Safety**: Type validation only, NOT behavior

**Important**: Each category focuses on different aspects for complete coverage

### 2. Test Naming Convention

```typescript
// Public API tests
it('should create component with valid function', () => {};

// Edge cases
it('should handle null input gracefully', () => {});

// Type safety
it('should provide correct type inference for all public elements', () => {});
```

### 3. Test Implementation Rules

- **Focused tests**: Each test validates one specific concept
- **Clear test names**: Descriptive names that explain what is being tested
- **Realistic scenarios**: Use real-world input values and expected outputs
- **Runtime validation**: Test behavior, NOT types
- **Shared utilities**: Use helpers to avoid duplication
- **Type testing**: Use ONLY `expectTypeOf().toBeFunction()`, `expectTypeOf().toBeString()` o `toEqualTypeOf()`
- **Type testing forbidden**: NO `toMatchTypeOf()`, `toHaveProperty()`, or other non-standard methods

## Common Test Patterns

### 1. Result Validation Pattern

```typescript
// Success case
const result = functionName('valid input');
expect(isOk(result)).toBe(true);
expect(unwrap(result)).toEqual(expectedValue);

// Error case
const errorResult = functionName('invalid input');
expect(isErr(errorResult)).toBe(true);
expect(unwrap(errorResult)).toEqual(expectedError);
```

### 2. Component Validation Pattern

```typescript
const component = createComponent('Rule', () => {});
expect(component).toBeDefined();
expect(typeof component).toBe('function');
expect(component.info).toBeDefined();
expect(component.meta).toBeDefined();
```

### 3. Type Safety Pattern

```typescript
expectTypeOf(functionName).toBeFunction();
expectTypeOf(functionName('input')).toEqualTypeOf<ExpectedType>();
expectTypeOf(ClassName).toBeConstructor();
expectTypeOf(new ClassName()).toBeInstanceOf(ClassName);
```

## Maintenance Workflow

**Adding Features**: Code → Documentation → Tests
**Updating Features**: Modify code → Update documentation → Update tests
**Removing Features**: Delete code → Update documentation → Update tests

## Quality Checklist

### Code Development Quality

- [ ] **Code written first** - Implementation before documentation
- [ ] **TSDoc used consistently** - All @public elements documented
- [ ] **NO @example tags** - Examples managed separately
- [ ] **Clear descriptions** - Explain what, not how
- [ ] **Proper tagging** - @public, @internal used correctly
- [ ] **Module agnostic** - No cross-module assumptions

### Test Quality

- [ ] **Focused tests** - Each test validates one specific concept
- [ ] **Clear test names** - Descriptive names that explain what is being tested
- [ ] **Realistic scenarios** - Use real-world input values and expected outputs
- [ ] **Error handling covered** - Both success and error cases tested
- [ ] **Edge cases included** - Boundary conditions and extreme scenarios
- [ ] **Module isolation** - Don't test cross-module dependencies

### Test Generation Quality

- [ ] **Comprehensive Public API testing** - Test all @public elements thoroughly
- [ ] **Edge cases and error handling** - Test boundary conditions and error scenarios
- [ ] **Comprehensive typechecking** - Test all @public elements with `expectTypeOf`
- [ ] **No overlap** - Each category focuses on different aspects
- [ ] **Focused test cases** - Each test validates one specific concept
- [ ] **Realistic scenarios** - Use real-world input values and expected outputs
- [ ] **Runtime validation** - Test behavior, NOT types
- [ ] **Shared utilities** - Use helpers to avoid duplication

## Implementation Steps

1. **Set up test structure** - Create `tests/module.spec.ts` files
2. **Write code with TSDoc** - Document @public elements clearly
3. **Plan test scenarios** - Identify what needs to be tested for each @public element

## Test Commands

**Run tests**: `pnpm test-project -- <module-name>` (e.g., `pnpm test-project -- event`). The `module-name` must be defined in `viteset.config.ts`.
